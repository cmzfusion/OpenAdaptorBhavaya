package org.bhavaya.ui.table;

import org.bhavaya.collection.IndexedSet;
import org.bhavaya.util.MutableInteger;
import org.bhavaya.util.Utilities;

import java.util.*;

/**
 * Created by IntelliJ IDEA.
 * User: Nick Ebbutt
 * Date: 29-Oct-2008
 * Time: 14:14:44
 *
 * This class hides the fact from the PivotModel that pivot values are represented internally as Strings
 * This should mean the model code can continue to work with fewer changes than would otherwise be necessary.
 * I made the change to represent the values as Strings in order to facilitate 'locking' a pivot column.
 * This is easier to handle if the locked pivot value can be persisted as a String since otherwise there is no
 * way to predict what class the value might be, and whether it will be persistable using bean serialization)
 *
 * The tricky bit is that we still need to support the natural ordering for pivot values which are comparable, and
 * can't just rely on the String comparability. It's important that the 'not locked' pivot values respect the
 * order implied by the real values, as opposed to their string representations.
 *
 * To make things even more thorny, the 'real' pivot values will be a mixture of Strings and the true data type for the
 * pivot data column, due to the need to support (undefined) values and Loading... values. (It is probably a bad thing to
 * have these special Strings cropping up since it seems to break the getColumnClass contract for one thing, but that's a design
 * decision in the CachedObjectGraph/BeanCollectionTableModel and I've broken too much already to want to revisit that
 * now). Still, the MixedClassPivotValueComparator here attempts to work around this by placing all String values to the
 * left of non-string values. It *might* work - but none of this gives me a warm feeling, I'm toying with the idea of
 * changing my idea template to remove my name from the autogenerated class comments.
 */
public class PivotValuesCollection {

    public static final String UNDEFINED_PIVOT_COLUMN_KEY = "(undefined)";
    private Set<String> lockedColumnPivotValues = new HashSet<String>();
    private IndexedSet<PivotValue> pivotValues = new IndexedSet<PivotValue>();
    private Map<String,MutableInteger> valueToUsageCount = new HashMap<String, MutableInteger>();
    private MixedClassPivotValueComparator comparator = new MixedClassPivotValueComparator();

    public void clear() {
        pivotValues.clear();
        valueToUsageCount.clear();
    }

    public boolean contains(Object value) {
        return pivotValues.contains(new PivotValue(convertPivotValueToString(value), value));
    }

    public void add(int insertPoint, Object value) {
        pivotValues.add(insertPoint, new PivotValue(convertPivotValueToString(value), value));
    }

    public int indexOf(Object value) {
        return pivotValues.indexOf(new PivotValue(convertPivotValueToString(value), value));
    }

    public void remove(Object value) {
        pivotValues.remove(new PivotValue(convertPivotValueToString(value), value));
    }

    public int size() {
        return pivotValues.size();
    }

    public int getPivotColumnIndex(Object value) {
        PivotValue pivotValue = new PivotValue(convertPivotValueToString(value), value);
        return Collections.binarySearch(pivotValues, pivotValue, comparator);
    }

    public Collection<String> getLockedPivotValues() {
        return lockedColumnPivotValues;
    }

    public boolean isLockedPivotValue(Object o) {
        return lockedColumnPivotValues.contains(convertPivotValueToString(o));
    }

    public boolean addLockedColumnPivotValue(String pivotValue) {
        return lockedColumnPivotValues.add(pivotValue);
    }

    public boolean removeLockedColumnPivotValue(String pivotValue) {
        return lockedColumnPivotValues.remove(pivotValue);
    }

    public void createUsageCount(Object value, MutableInteger mutableInteger) {
        String pivotValueAsString = PivotValuesCollection.convertPivotValueToString(value);
        valueToUsageCount.put(pivotValueAsString, mutableInteger);
    }

    public void removeUsageCount(Object value) {
        String pivotValueAsString = PivotValuesCollection.convertPivotValueToString(value);
        valueToUsageCount.remove(pivotValueAsString);
    }

    public MutableInteger getUsageCount(Object value) {
        String pivotValueAsString = PivotValuesCollection.convertPivotValueToString(value);
        return valueToUsageCount.get(pivotValueAsString);
    }


    public static String convertPivotValueToString(Object value) {
        return value != null ? value.toString() : UNDEFINED_PIVOT_COLUMN_KEY;
    }

    private static class PivotValue {

        private String pivotValue;
        private Comparable comparisonObject;

        public PivotValue(String pivotValue, Object comparison) {
            this.pivotValue = pivotValue;
            this.comparisonObject = comparison instanceof Comparable ? (Comparable)comparison : pivotValue;
        }

        public int hashCode() {
            return pivotValue.hashCode();
        }

        public boolean equals(Object o) {
            if ( o == this ) return true;
            boolean result = false;
            if ( o instanceof PivotValue) {
                PivotValue v = (PivotValue)o;
                if ( v.pivotValue.equals(pivotValue)) {
                    result = true;
                }
            }
            return result;
        }

        public Comparable getComparisonObject() {
            return comparisonObject;
        }
    }

    public static class MixedClassPivotValueComparator implements Comparator<PivotValue> {

        public int compare(PivotValue o1, PivotValue o2) {
            Comparable c1 = o1.getComparisonObject();
            Comparable c2 = o2.getComparisonObject();
            if ( c1 instanceof String &&  ! (c2 instanceof String)) return -1;
            if ( c2 instanceof String && ! (c1 instanceof String)) return 1;
            return Utilities.compare(c1, c2);
        }
    }
}
