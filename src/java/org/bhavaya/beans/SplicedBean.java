package org.bhavaya.beans;

import org.bhavaya.util.Type;
import org.bhavaya.util.Generic;
import org.bhavaya.util.Attribute;

import java.util.Arrays;
import java.util.List;
import java.util.Set;
import java.util.HashSet;

/**
 * Instances of this class (and its subclasses) are intended to be generated by a SplicedBeanCollection.
 * <p/>
 * Spliced beans have properties that are delegated to two member beans of different types.
 * <p/>
 * Each class should have a property that specifies how to map from an instance of one class to an instance of the other
 * and this should be a one-to-one mapping. This property is returned by the generateUniqueId method.
 * <p/>
 * The join property should be returned by the generate unique id method, and must be different on objects of the same class
 * whose equals/hashcode are different (thus enforcing the one-to-one mapping requirement). This is the responsibility of the
 * subclass, but gives flexibility on picking the join property. (This condition is so that each member of a source bean
 * collection has one and only one corresponding member in the combined collectin. Source collections are unique on source bean
 * equals/hashcode, the combined collection is unique on the join property.)
 *
 * Note that at the moment, property change events on the underlying bean are not passed through to the SplicedBean, although
 * there's no reason why listeners could not be set up to do this, it's just that it's not currently required.
 *
 * @author Andrew J. Dean
 * @version $Revision: 1.3 $
 */
public abstract class SplicedBean extends Bean {
    private Object uniqueId;
    private static final List EXCLUDED_PROPERTIES = Arrays.asList(new String[]{"class", "propertyChangeDescriptor"});
    private static final String commonPropertyLock = "CommonPropertyLock";
    private static Set commonProperties;
    private boolean commonPropertiesInited = false;

    public SplicedBean(Object eitherMember) {
        this.uniqueId = generateUniqueId(eitherMember);
    }

    public Object getUniqueId() {
        return uniqueId;
    }

    public void setUniqueId(Object uniqueId) {
        this.uniqueId = uniqueId;
    }

    /**
     * This call should return a unique identifier that can be used to join the two
     * components of the spliced bean together. One way to do this could be to use
     * an EfficientArrayList whose components are the relevant properties from the underlying objects.
     *
     * @param object Object can be either member of the spliced bean
     * @return An object representing the join property of each component of the spliced bean
     */
    public abstract Object generateUniqueId(Object object);

    // These 3 methods are ripe for a refactoring! If subclasses call a super constructor
    // super(Object eitherMember, Class bean1Type, Class bean2Type) we could dynamic dispatch these.
    // would need methods like getBean1(), setBean1(Object bean1)
    public abstract void update(Object updatedBean);

    public abstract void remove(Object beanToRemove);

    public abstract boolean hasData();

    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        SplicedBean that = (SplicedBean) o;

        return uniqueId.equals(that.uniqueId);
    }

    public int hashCode() {
        return uniqueId.hashCode();
    }

    /**
     * This method can return an empty string array. Only needs to be implemented if you're going
     * to use the <code>fireNewComponentObject</code> method.
     * @return Names of properties obtainable from either of the underlying component objects
     */
    protected abstract String[] getPropertiesCommonToBothMembers();

    /**
     * Generate property change events for this class, for all properties derived from one of
     * its component objects.
     *
     * This method isn't called by this class, but you may want to call it as part of your
     * update / remove methods.
     *
     * At the moment, assume underlying class's property name = this class's property name
     *
     * @param clazz Class of oldObject and newObject
     * @param oldObject object with original property values
     * @param newObject object with new property values
     */
    protected void fireNewComponentObject(Class clazz, Object oldObject, Object newObject) {
        Type genericType = Generic.getType(clazz);
        int numberOfAttributes = genericType.getAttributes().length;

        for (int i = 0; i < numberOfAttributes; i++) {
            Attribute attribute = genericType.getAttribute(i);
            String propertyName = attribute.getName();
            if (!EXCLUDED_PROPERTIES.contains(propertyName) && !isCommon(propertyName)) {
                Object oldPropertyValue = oldObject == null ? null : Generic.get(oldObject, propertyName);
                Object newPropertyValue = newObject == null ? null : Generic.get(newObject, propertyName);
                firePropertyChange(propertyName, oldPropertyValue, newPropertyValue);
            }
        }
    }

    private boolean isCommon(String propertyName) {
        synchronized (commonPropertyLock) {
            if (!commonPropertiesInited) {
                String[] propertyNames = getPropertiesCommonToBothMembers();
                commonProperties = new HashSet(propertyNames.length);
                for (int i = 0; i < propertyNames.length; i++) {
                    commonProperties.add(propertyNames[i]);
                }
                commonPropertiesInited = true;
            }
        }
        return commonProperties.contains(propertyName);
    }
}

