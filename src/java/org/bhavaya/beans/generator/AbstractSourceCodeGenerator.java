/* Copyright (C) 2000-2003 The Software Conservancy as Trustee.
 * All rights reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * Nothing in this notice shall be deemed to grant any rights to trademarks,
 * copyrights, patents, trade secrets or any other intellectual property of the
 * licensor or any contributor except as expressly stated herein. No patent
 * license is granted separate from the Software, for code that you delete from
 * the Software, or for combinations of the Software with other software or
 * hardware.
 */

package org.bhavaya.beans.generator;

import org.bhavaya.beans.Schema;
import org.bhavaya.util.ClassUtilities;
import org.bhavaya.util.Log;
import org.bhavaya.util.Utilities;

import java.io.File;
import java.io.IOException;
import java.util.Date;

/**
 * Description.
 *
 * @author Parwinder Sekhon
 * @version $Revision: 1.4 $
 */
public class AbstractSourceCodeGenerator extends CodeGenerator {
    private static final Log log = Log.getCategory(AbstractSourceCodeGenerator.class);
    private static final String INDENT = "    ";
    private String rootDirectory;
    private StringBuffer sourceCode;
    private String classPrefix = "Abstract";

    public AbstractSourceCodeGenerator(String rootDirectory) {
        super();
        if (rootDirectory == null) throw new IllegalArgumentException("rootDirectory is null");
        Schema.setGenerationMode(true);
        this.rootDirectory = rootDirectory;
    }

    protected void startGenerateClass(String classToGenerate) {
        sourceCode = new StringBuffer(5000);
    }

    protected void endGenerateClass(String classToGenerate) {
        sourceCode.append("}").append('\n');

        try {
            String abstractClass = Utilities.getQualifier(classToGenerate, '.') + "." + classPrefix + Utilities.getUnqualifiedName(classToGenerate, '.');

            String fileName = rootDirectory + File.separator + abstractClass.replace('.', File.separatorChar) + ".java";
            log.info("Writing " + abstractClass + " to " + fileName);
            writeStringToFile(fileName, sourceCode.toString());
        } catch (IOException e) {
            log.error(e);
        }
    }

    protected void appendHeader(String classToGenerate, String superClassOfGeneratedBean, String superClassOfBean, Class[] interfacesToImplement) {
        String packageForGeneratedClass = ClassUtilities.getPackageName(classToGenerate);

        sourceCode.append("package ").append(packageForGeneratedClass).append(';').append('\n');
        sourceCode.append('\n');

        // Javadoc Header
        sourceCode.append("/**").append('\n');
        sourceCode.append(" * Generated by ").append(this.getClass().getName()).append(" on ").append(new Date()).append('\n');
        sourceCode.append(" *").append('\n');
        sourceCode.append(" * @author Bhavaya").append('\n');
        sourceCode.append(" * @version $Revision: 1.4 $").append('\n');
        sourceCode.append(" */").append('\n');

        // Class declaration
        String unqualifiedClassName = classPrefix + ClassUtilities.getUnqualifiedClassName(classToGenerate);
        sourceCode.append("public abstract class ").append(unqualifiedClassName).append(" extends ").append(superClassOfBean).append(" {").append('\n');
        sourceCode.append('\n');
    }

    protected void appendConstructor(String classToGenerate, Class[] constructorParameters) {
    }

    protected void appendToString(String toStringCode) {
    }

    protected void appendField(String propertyName, String propertyType) {
    }

    protected void appendGetter(String propertyName, String propertyType, boolean lazy) {
        String getMethodName = getGetMethodName(propertyType, propertyName, true);
        sourceCode.append(INDENT).append("public abstract ").append(propertyType).append(" ").append(getMethodName).append(";").append('\n');
    }

    protected void appendCollectionGetter(String propertyName, String componentPropertyType, boolean lazy, String foreignIndex) {
        Class propertyType = org.bhavaya.collection.BeanCollection.class;
        String getMethodName = getGetMethodName(propertyType.getName(), propertyName, true);
        sourceCode.append(INDENT).append("public abstract ").append(propertyType.getName()).append(" ").append(getMethodName).append(";").append('\n');
    }

    protected void appendArrayGetter(String propertyName, String propertyType, String componentPropertyType, String collectionPropertyName) {
        sourceCode.append(INDENT).append("public abstract ").append(propertyType).append(" get").append(Utilities.capitalise(propertyName)).append("()").append(";").append('\n');
    }

    protected void appendSetter(String propertyName, String propertyType, String superClass, boolean lazy, boolean many, boolean hasSuperSetter) {
        String setMethodName = getSetMethodName(propertyName);
        sourceCode.append(INDENT).append("public abstract void ").append(setMethodName).append("(").append(propertyType).append(' ').append(propertyName).append(") ").append(";").append('\n');
    }
}
